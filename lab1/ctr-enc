#!/usr/bin/env python3

from sys import argv,exit
from Crypto.Cipher import AES
from Crypto import Random
from multiprocessing import Pool
import os.path
import threading

def main():
	if len(argv) != 7:
		print("Usage: ./ctr-enc.py -k <key file> -i <input file> -o <output file>")
		raise Exception("Bad Command Line Args")

	fin = open(argv[2],"r")
	hexKey = fin.read()
	fin.close()
	fout = open(argv[6],"wb+")

	counter = 0
	messageBlocks = []
	fin = open(argv[4],"rb")
	while 1:
		temp = bytearray(fin.read(16)) 
		if temp == bytes('','utf-8'):
			break
		messageBlocks.append(temp)
		counter += 1
	fin.close()	

	IV = bytes(os.urandom(16))
	IVint=int.from_bytes(IV,byteorder='big')
	IVint += 1
	cipher = AES.new(bytes.fromhex(hexKey),AES.MODE_ECB)
	fout.write(bytes(IV))

#	for i in range (0,counter):
#		interMed = bytearray(cipher.encrypt(IVint.to_bytes(16,byteorder='big')))
#		for j in range (0,len(messageBlocks[i])):
#			messageBlocks[i][j] ^= interMed[i]
#		fout.write(messageBlocks[i])
#		IVint+=1

#	fout.close()
# make a tuple of block and y 
	plz=()
	for x in messageBlocks:
		plz=plz+(x,IVint)			
		IVint+=1

	print(plz)
	with Pool(4) as p:
		cipherTexts = [p.apply(encrypt,args=(plz[x],plz[x+1],hexKey)) for x in range(0,len(plz)-1,2)]

#	print(len(cipherTexts))
	for a in range(0,len(cipherTexts)):
		fout.write(str(cipherTexts[a]).encode())
		print(cipherTexts[a])	
	fout.close()

def encrypt(msg,IV,hexKey):
	print(msg)
	print(IV)
	print()
	cipher = AES.new(bytes.fromhex(hexKey),AES.MODE_ECB)
	interMed = bytearray(cipher.encrypt(IV.to_bytes(16,byteorder='big')))
	for i in range (0,len(msg)):
		msg[i] ^= interMed[i]

	return msg	
	


if __name__ == "__main__":
	exit(main())
